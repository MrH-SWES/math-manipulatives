<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
  <title>Place Value Blocks</title>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700;900&display=swap" rel="stylesheet"/>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    :root{
      --bg:#f3f4f6; 
      --ink:#111827;
      --tray:#1f2937; 
      --tab-inactive:#374151;
      --tab-active:#4b5563;
      --shadow:rgba(0,0,0,.25);
      --block-size: 60px;
      --block-height: 110px;
      
      /* Montessori-style Colors */
      /* Ones family (Green) */
      --c-ones: #16a34a; 
      --c-thousands: #16a34a;
      --c-millions: #16a34a;
      
      /* Tens family (Blue) */
      --c-tens: #2563eb;
      --c-ten-thousands: #2563eb;
      
      /* Hundreds family (Red) */
      --c-hundreds: #dc2626;
      --c-hundred-thousands: #dc2626;

      /* Decimals (Lighter versions) */
      --c-tenths: #93c5fd; /* Light Blue */
      --c-hundredths: #fca5a5; /* Light Red */
      --c-thousandths: #86efac; /* Light Green */
    }

    body{font-family:'Lexend',sans-serif;background:var(--bg);color:var(--ink);height:100vh;overflow:hidden;touch-action:manipulation}

    #app{position:relative;height:100%;width:100%}

    /* WORKSPACE */
    #workPane{position:absolute;inset:0 0 30vh 0;background:radial-gradient(circle at center, #ffffff 0%, #e5e7eb 100%);overflow:hidden}
    
    .hint{position:absolute;left:50%;top:30%;transform:translate(-50%,-50%);color:#9ca3af;font-size:18px;text-align:center;pointer-events:none; font-weight:600; opacity: 0.7;}
    
    /* Snap line for place value alignment */
    #snapLine{
      position:absolute;
      top:50%;
      left:0;
      right:0;
      height:4px;
      background:rgba(0,0,0,0.1);
      pointer-events:none;
      z-index:5;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    /* The center Decimal Point Indicator */
    #snapLine::after{
      content:'.';
      font-size: 60px;
      font-weight: 900;
      color: #111827;
      margin-bottom: 20px; /* Align visually with text baseline */
      text-shadow: 0 2px 0 rgba(255,255,255,1);
    }

    /* CARD STYLES */
    .tile{
      height:var(--block-height);
      display:flex;
      cursor:grab;
      user-select:none;
      flex-shrink:0;
      touch-action:none;
      border-radius:8px;
      box-shadow: 4px 4px 0 rgba(0,0,0,0.2);
      overflow:hidden;
      transition: transform 0.1s;
      background: white; /* Fallback */
    }
    .tile:active{cursor:grabbing; transform: scale(1.02);}
    .tile.dragging{position:fixed;opacity:0.9;pointer-events:none;will-change:transform;left:0;top:0; z-index: 9999 !important;}
    .work-pane-tile{position:absolute; transition: left 0.2s cubic-bezier(0.2, 1.2, 0.5, 1), top 0.2s cubic-bezier(0.2, 1.2, 0.5, 1);}

    /* Individual digit block */
    .digit-block{
      width:var(--block-size);
      height:var(--block-height);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:800;
      font-size:48px;
      line-height: 1;
    }
    
    .comma-block{ width:20px; font-size:48px; justify-content: center; padding-bottom: 15px; align-items: flex-end;}
    .decimal-block{ width:15px; font-size:56px; font-weight:900; align-items:flex-end; padding-bottom:15px; justify-content: center;}

    /* COLOR CLASSES */
    .pv-ones, .pv-thousands, .pv-millions { background: var(--c-ones); color: white; }
    .pv-tens, .pv-tenThousands { background: var(--c-tens); color: white; }
    .pv-hundreds, .pv-hundredThousands { background: var(--c-hundreds); color: white; }
    
    /* Decimals - Dark text */
    .pv-tenths { background: var(--c-tenths); color: #1e3a8a; }
    .pv-hundredths { background: var(--c-hundredths); color: #7f1d1d; }
    .pv-thousandths { background: var(--c-thousandths); color: #14532d; }

    /* Label on top of cards (Optional, good for learning) */
    .tile::before {
      content: attr(data-label);
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      opacity: 0.8;
      font-weight: normal;
      text-transform: uppercase;
    }

    #controls{position:absolute;top:15px;left:15px;display:flex;gap:10px;z-index:10}
    .btn{background:#1f2937;color:#fff;border:none;border-radius:8px;padding:8px 16px;cursor:pointer;font-weight:600;font-size:14px;box-shadow:0 4px 6px rgba(0,0,0,0.1); transition: all 0.2s;}
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 6px 8px rgba(0,0,0,0.15);}
    .btn.danger{background:#ef4444;}
    .btn.danger:hover{background:#dc2626;}

    /* BOTTOM DOCK */
    #bottomDock{position:absolute;left:0;right:0;bottom:0;height:30vh;pointer-events:none;z-index:20;display:flex;flex-direction:column}

    /* TABS */
    #drawerTabs{
      display:flex;
      background:#374151;
      pointer-events:auto;
      overflow-x:auto;
      flex-shrink:0;
      padding: 0 10px;
      scrollbar-width: none; /* Hide scrollbar FF */
    }
    #drawerTabs::-webkit-scrollbar { display: none; }

    .drawer-tab{
      padding:10px 20px;
      background:transparent;
      color: #d1d5db;
      border:none;
      cursor:pointer;
      font-weight:700;
      font-size:13px;
      white-space:nowrap;
      transition:all .2s;
      flex-shrink:0;
      font-family:'Lexend',sans-serif;
      border-bottom: 4px solid transparent;
    }
    .drawer-tab:hover{color: white; background: rgba(255,255,255,0.05);}
    .drawer-tab.active{
      color: white;
      background: rgba(0,0,0,0.2);
      border-bottom: 4px solid #3b82f6;
    }

    /* TILES AREA */
    #baseTiles{
      flex:1;
      background:#1f2937;
      padding:15px;
      pointer-events:auto;
      box-shadow:0 -4px 20px rgba(0,0,0,0.15);
      overflow-x: auto;
      overflow-y: hidden;
      display:flex;
      align-items:center;
      justify-content:flex-start; /* Changed from center to allow scrolling */
    }
    .base-row{
      display:flex;
      flex-wrap:nowrap; /* Horizontal scroll usually better for math cards */
      gap:15px;
      padding: 0 20px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="workPane">
      <div id="snapLine"></div>
      <div class="hint">Drag cards to the center line to build numbers</div>
      <div id="controls">
        <button id="resetButton" class="btn danger">Clear Workspace</button>
      </div>
    </div>

    <!-- bottom dock with drawer tabs -->
    <div id="bottomDock">
      <!-- drawer tabs -->
      <div id="drawerTabs">
        <button class="drawer-tab" data-drawer="millions">Millions</button>
        <button class="drawer-tab" data-drawer="hundredThousands">Hundred Thousands</button>
        <button class="drawer-tab" data-drawer="tenThousands">Ten Thousands</button>
        <button class="drawer-tab" data-drawer="thousands">Thousands</button>
        <button class="drawer-tab" data-drawer="hundreds">Hundreds</button>
        <button class="drawer-tab" data-drawer="tens">Tens</button>
        <button class="drawer-tab active" data-drawer="ones">Ones</button>
        <button class="drawer-tab" data-drawer="tenths">Tenths</button>
        <button class="drawer-tab" data-drawer="hundredths">Hundredths</button>
        <button class="drawer-tab" data-drawer="thousandths">Thousandths</button>
      </div>
      <!-- tiles area -->
      <div id="baseTiles">
        <div class="base-row" id="baseRow"></div>
      </div>
    </div>
  </div>

  <script>
    // ====== CONFIG ======
    const BLOCK_SIZE = 60;
    const BLOCK_HEIGHT = 110;
    const SNAP_DISTANCE = 40;
    const SNAP_LINE_DISTANCE = 80; 
    
    // ====== PLACE VALUE DATA ======
    const PLACE_VALUES = {
      tenths: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9],
      hundredths: [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09],
      thousandths: [0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009],
      ones: [1, 2, 3, 4, 5, 6, 7, 8, 9],
      tens: [10, 20, 30, 40, 50, 60, 70, 80, 90],
      hundreds: [100, 200, 300, 400, 500, 600, 700, 800, 900],
      thousands: [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000],
      tenThousands: [10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000],
      hundredThousands: [100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000],
      millions: [1000000, 2000000, 3000000, 4000000, 5000000, 6000000, 7000000, 8000000, 9000000]
    };

    // ====== STATE ======
    let tiles = []; 
    let activeDrawer = 'ones'; 

    // drag state
    let draggedTile = null;
    let dragOffset = {x: 0, y: 0};
    let gesture = null;

    // ====== UTIL ======
    function getPlaceValueType(value) {
      if (value < 0.01) return 'thousandths';
      if (value < 0.1) return 'hundredths';
      if (value < 1) return 'tenths';
      if (value < 10) return 'ones';
      if (value < 100) return 'tens';
      if (value < 1000) return 'hundreds';
      if (value < 10000) return 'thousands';
      if (value < 100000) return 'tenThousands';
      if (value < 1000000) return 'hundredThousands';
      return 'millions';
    }

    // Map types to CSS color classes
    function getVisualClass(type) {
      return `pv-${type}`;
    }

    function getDigitsArray(value) {
      let str;
      if (value < 1) {
        if (value < 0.01) str = value.toFixed(3);
        else if (value < 0.1) str = value.toFixed(2);
        else str = value.toFixed(1);
        const parts = str.split('.');
        return ['.', ...parts[1].split('')];
      } else {
        str = String(Math.floor(value));
      }
      
      const result = [];
      const wholeDigits = str.split('');
      
      for (let i = 0; i < wholeDigits.length; i++) {
        result.push(wholeDigits[i]);
        const posFromRight = wholeDigits.length - i - 1;
        if (posFromRight > 0 && posFromRight % 3 === 0) {
          result.push(',');
        }
      }
      return result;
    }

    function getCardWidth(placeValue) {
      const sampleVal = PLACE_VALUES[placeValue][0];
      const digits = getDigitsArray(sampleVal);
      
      let width = 0;
      for (let char of digits) {
        if (char === ',') width += 20;
        else if (char === '.') width += 15;
        else width += BLOCK_SIZE;
      }
      return width;
    }

    function getPlaceValueOrder(placeValue) {
      const order = { 
        thousandths: 1, hundredths: 2, tenths: 3,
        millions: 4, hundredThousands: 5, tenThousands: 6, 
        thousands: 7, hundreds: 8, tens: 9, ones: 10
      };
      return order[placeValue];
    }

    function getSnapLinePosition(placeValue) {
      const workPane = document.getElementById('workPane');
      const paneRect = workPane.getBoundingClientRect();
      const snapLine = document.getElementById('snapLine');
      const lineRect = snapLine.getBoundingClientRect();
      
      const snapY = lineRect.top - paneRect.top - (BLOCK_HEIGHT / 2);
      const centerX = (paneRect.width / 2);
      const cardWidth = getCardWidth(placeValue);
      
      const isDecimal = ['thousandths','hundredths','tenths'].includes(placeValue);
      
      if (isDecimal) {
        return { x: centerX, y: snapY };
      } else {
        return { x: centerX - cardWidth, y: snapY };
      }
    }

    function findOverlayTarget(dropX, dropY, droppedPlaceValue, excludeId) {
      const droppedOrder = getPlaceValueOrder(droppedPlaceValue);
      const droppedWidth = getCardWidth(droppedPlaceValue);

      let bestMatch = null;
      let bestDistance = Infinity;

      for (const tile of tiles) {
        if (tile.id === excludeId) continue;

        // Check vertical proximity first to avoid checking every tile
        if (Math.abs(tile.y - dropY) > 50) continue;

        const targetOrder = getPlaceValueOrder(tile.placeValue);
        const droppedIsDecimal = ['thousandths','hundredths','tenths'].includes(droppedPlaceValue);
        const targetIsDecimal = ['thousandths','hundredths','tenths'].includes(tile.placeValue);
        
        let canOverlay = false;
        let snapX, snapY;
        
        // Whole Number Logic: Standard form stacking (smallest on top of largest)
        // In this stacking logic:
        // To stack "5" on "30", Ones(10) > Tens(9). 
        // So if droppedOrder > targetOrder, we align Right edges.
        
        if (!droppedIsDecimal && !targetIsDecimal && droppedOrder > targetOrder) {
          canOverlay = true;
          const targetWidth = getCardWidth(tile.placeValue);
          snapX = tile.x + targetWidth - droppedWidth;
          snapY = tile.y;
        } 
        else if (droppedIsDecimal && !targetIsDecimal) {
          canOverlay = true;
          const targetWidth = getCardWidth(tile.placeValue);
          snapX = tile.x + targetWidth; // Decimals snap to right edge of whole numbers
          snapY = tile.y;
        } 
        else if (droppedIsDecimal && targetIsDecimal && droppedOrder > targetOrder) {
          canOverlay = true;
          snapX = tile.x; // Decimals align left (at the point)
          snapY = tile.y;
        }
        
        if (!canOverlay) continue;

        const dx = dropX - snapX;
        const dy = dropY - snapY;
        const distance = Math.sqrt(dx*dx + dy*dy);

        if (distance < SNAP_DISTANCE && distance < bestDistance) {
          bestDistance = distance;
          bestMatch = { tile, snapX, snapY };
        }
      }

      return bestMatch;
    }

    // ====== DOM BUILDERS ======
    function createTile(value, source) {
      const el = document.createElement('div');
      const placeValue = getPlaceValueType(value);
      const digits = getDigitsArray(value);
      const colorClass = getVisualClass(placeValue);

      el.className = `tile ${colorClass}`;
      el.dataset.value = value;
      el.dataset.placeValue = placeValue;
      el.dataset.source = source;
      
      // Label for accessibility/learning
      // el.dataset.label = placeValue;

      digits.forEach(char => {
        const digitBlock = document.createElement('div');
        if (char === ',') {
          digitBlock.className = 'digit-block comma-block';
          digitBlock.textContent = ',';
        } else if (char === '.') {
          digitBlock.className = 'digit-block decimal-block';
          digitBlock.textContent = '.';
        } else {
          digitBlock.className = 'digit-block';
          digitBlock.textContent = char;
        }
        el.appendChild(digitBlock);
      });

      el.addEventListener('pointerdown', (e) => onPointerStart(e, value, source));
      return el;
    }

    function renderTray() {
      renderActiveDrawer();
    }

    function renderActiveDrawer() {
      const baseRow = document.getElementById('baseRow');
      baseRow.innerHTML = '';
      
      const vals = PLACE_VALUES[activeDrawer] || [];
      vals.forEach(val => {
        baseRow.appendChild(createTile(val, 'tray'));
      });
    }

    function renderWorkPane() {
      const workPane = document.getElementById('workPane');
      const hint = workPane.querySelector('.hint');
      workPane.querySelectorAll('.work-pane-tile').forEach(el => el.remove());
      
      hint.style.display = tiles.length > 0 ? 'none' : 'block';

      // Sort for rendering order
      const sortedTiles = [...tiles].sort((a, b) => a.zIndex - b.zIndex);

      sortedTiles.forEach(tile => {
        const digits = getDigitsArray(tile.value);
        const colorClass = getVisualClass(tile.placeValue);

        const el = document.createElement('div');
        el.className = `tile work-pane-tile ${colorClass}`;
        el.dataset.value = tile.value;
        
        digits.forEach(char => {
          const digitBlock = document.createElement('div');
          if (char === ',') {
            digitBlock.className = 'digit-block comma-block';
            digitBlock.textContent = ',';
          } else if (char === '.') {
            digitBlock.className = 'digit-block decimal-block';
            digitBlock.textContent = '.';
          } else {
            digitBlock.className = 'digit-block';
            digitBlock.textContent = char;
          }
          el.appendChild(digitBlock);
        });

        el.style.left = tile.x + 'px';
        el.style.top = tile.y + 'px';
        el.style.zIndex = tile.zIndex;

        el.addEventListener('pointerdown', (e) => onPointerStart(e, tile.value, tile.id));
        workPane.appendChild(el);
      });
    }

    // ====== DRAG HANDLING ======
    function onPointerStart(e, value, source) {
      e.preventDefault();
      e.stopPropagation();
      
      // Capture pointer for smooth dragging even if mouse leaves div
      if (e.currentTarget.setPointerCapture) {
        try { e.currentTarget.setPointerCapture(e.pointerId); } catch(_) {}
      }

      const targetRect = e.currentTarget.getBoundingClientRect();
      const startX = e.clientX;
      const startY = e.clientY;

      gesture = {
        startX, startY,
        moved: false,
        source, value,
        pointerType: e.pointerType
      };

      const onMove = (ev) => {
        if (!gesture) return;
        const dx = ev.clientX - gesture.startX;
        const dy = ev.clientY - gesture.startY;

        if (!gesture.moved && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
          gesture.moved = true;
          beginDrag(gesture, targetRect);
        }
        if (gesture.moved) handleMove(ev);
      };

      const onEnd = (ev) => {
        handleEnd(ev);
        cleanup();
      };

      function cleanup() {
        document.removeEventListener('pointermove', onMove);
        document.removeEventListener('pointerup', onEnd);
        document.removeEventListener('pointercancel', onEnd);
        gesture = null;
      }

      document.addEventListener('pointermove', onMove, {passive: false});
      document.addEventListener('pointerup', onEnd, {passive: false});
      document.addEventListener('pointercancel', onEnd, {passive: false});
    }

    function beginDrag(g, targetRect) {
      const placeValue = getPlaceValueType(g.value);
      
      if (g.source === 'tray') {
        draggedTile = {
          value: g.value,
          placeValue,
          x: g.startX,
          y: g.startY,
          sourceType: 'tray'
        };
      } else {
        const paneTile = tiles.find(t => t.id === g.source);
        if (!paneTile) return;
        draggedTile = {
          ...paneTile,
          sourceType: 'pane'
        };
      }

      dragOffset = {
        x: g.startX - targetRect.left,
        y: g.startY - targetRect.top
      };

      updateDragVisual();
    }

    function handleMove(e) {
      if (!draggedTile) return;
      e.preventDefault();
      draggedTile.x = e.clientX;
      draggedTile.y = e.clientY;
      updateDragVisual();
    }

    function handleEnd(e) {
      if (!draggedTile) return;
      e.preventDefault();

      const workPane = document.getElementById('workPane');
      const paneRect = workPane.getBoundingClientRect();

      // Check if dropped inside work pane
      const inside = e.clientY < paneRect.bottom;

      if (inside) {
        let dropX = e.clientX - paneRect.left - dragOffset.x;
        let dropY = e.clientY - paneRect.top - dragOffset.y;

        // Check snap line
        const snapLinePos = getSnapLinePosition(draggedTile.placeValue);
        const distanceToLine = Math.abs(dropY - snapLinePos.y);

        let finalX, finalY, parentId = null;
        const order = getPlaceValueOrder(draggedTile.placeValue);
        let zIndex = 1000 + order; // Higher order (Ones) on top of Lower order (Hundreds)

        if (distanceToLine < SNAP_LINE_DISTANCE) {
          finalX = snapLinePos.x;
          finalY = snapLinePos.y;
        } else {
          // Overlay check
          const overlay = findOverlayTarget(dropX, dropY, draggedTile.placeValue, 
            draggedTile.sourceType === 'pane' ? draggedTile.id : null);

          if (overlay) {
            finalX = overlay.snapX;
            finalY = overlay.snapY;
            parentId = overlay.tile.id;
          } else {
            finalX = dropX;
            finalY = dropY;
          }
        }

        if (draggedTile.sourceType === 'tray') {
          const newTile = {
            id: Date.now() + Math.random(),
            value: draggedTile.value,
            placeValue: draggedTile.placeValue,
            x: finalX,
            y: finalY,
            parentId,
            zIndex
          };
          tiles.push(newTile);
        } else {
          const existingTile = tiles.find(t => t.id === draggedTile.id);
          if (existingTile) {
            existingTile.x = finalX;
            existingTile.y = finalY;
            existingTile.parentId = parentId;
            existingTile.zIndex = zIndex;
          }
        }
      } else if (draggedTile.sourceType === 'pane') {
        // Tossed out of pane
        tiles = tiles.filter(t => t.id !== draggedTile.id);
      }

      draggedTile = null;
      clearDragVisual();
      renderWorkPane();
    }

    // ====== DRAG VISUALS ======
    function updateDragVisual() {
      clearDragVisual();
      if (!draggedTile) return;

      const colorClass = getVisualClass(draggedTile.placeValue);
      const g = document.createElement('div');
      g.className = `tile ${colorClass} dragging`;

      const digits = getDigitsArray(draggedTile.value);
      digits.forEach(char => {
        const digitBlock = document.createElement('div');
        if (char === ',') {
          digitBlock.className = 'digit-block comma-block';
          digitBlock.textContent = ',';
        } else if (char === '.') {
          digitBlock.className = 'digit-block decimal-block';
          digitBlock.textContent = '.';
        } else {
          digitBlock.className = 'digit-block';
          digitBlock.textContent = char;
        }
        g.appendChild(digitBlock);
      });

      const gx = draggedTile.x - dragOffset.x;
      const gy = draggedTile.y - dragOffset.y;
      g.style.transform = `translate3d(${gx}px, ${gy}px, 0) rotate(-2deg) scale(1.05)`;
      
      // High z-index for drag
      g.style.zIndex = 99999;
      
      g.dataset.dragging = 'true';
      document.body.appendChild(g);
    }

    function clearDragVisual() {
      document.querySelectorAll('[data-dragging="true"]').forEach(el => el.remove());
    }

    // ====== TABS ======
    function switchDrawer(drawerName) {
      activeDrawer = drawerName;
      
      document.querySelectorAll('.drawer-tab').forEach(tab => {
        const isActive = tab.dataset.drawer === drawerName;
        if(isActive) {
          tab.classList.add('active');
          // Scroll tab into view
          tab.scrollIntoView({behavior: 'smooth', inline: 'center', block: 'nearest'});
        } else {
          tab.classList.remove('active');
        }
      });
      renderActiveDrawer();
    }

    // ====== INIT ======
    document.getElementById('resetButton').addEventListener('click', () => {
      tiles = [];
      renderWorkPane();
    });

    document.querySelectorAll('.drawer-tab').forEach(tab => {
      tab.addEventListener('click', (e) => {
        switchDrawer(tab.dataset.drawer);
      });
    });

    // Start at Ones
    switchDrawer('ones');
    renderTray();
    renderWorkPane();
  </script>
</body>
</html>
